//------------------------------------------------------------------------------
// <auto-generated>
//     Este código fue generado por una herramienta.
//     Versión de runtime:4.0.30319.42000
//
//     Los cambios en este archivo podrían causar un comportamiento incorrecto y se perderán si
//     se vuelve a generar el código.
// </auto-generated>
//------------------------------------------------------------------------------
// using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;
using Godot;

namespace FuetEngine
{
    public class CLibConfigReader
	{
        public bool bExists(string _sVariable)
        {
            return (m_oVars.ContainsKey(_sVariable));
        }

        public CVariable oGetVariable(string _sVariable)
        {
            return (m_oVars[_sVariable]);
        }

        public CLibConfigReader ()
		{
		}

		// --------------------------------------------
		public bool bRead(string _sFilename)
		{
			char[] szConfig = pucReadFile(_sFilename);
			if (szConfig == null)
			{
				string msg;
				msg = "Unable to read input file " + _sFilename + "\n";
                Console.Write(msg);
                // Debug.Log(msg);
				return(false);
			}
			
			// Remove comments.
			PreprocessComments(szConfig);
			
			// take out \r \n \t
			SubstChar(szConfig,'\t');
			SubstChar(szConfig,'\r');
            // SubstChar(szConfig,'\n');

            int iPos = 0;
			sParseStream(szConfig,ref iPos);
            return(true);
		}

		public void PrintVarList()
		{
            /*
            for (int i = 0; i < m_oVarList.Count; i++)
                // Debug.Log( m_oVarList[i].sGetName() + " = " + m_oVarList[i].sGetValue() + "\n" );
                Console.Write(m_oVarList[i].sGetName() + " = " + m_oVarList[i].sGetValue() + "\n");
			*/
		}

        // ----------------------------------------------------------------------------
        private string sParseStream(char[] _szStream,ref int i)
		{
			// ------------------------------------------
			// Look if the stream starts with a section
			// ------------------------------------------
			string sID = "";
			bool bInString = false;
			// int i = _iStartPos;

			while ( _szStream[i] != 0)
			{
				char c = _szStream[i];
				i++;
				
				if (bInString)
				{
					sID = sID + c;
					
					if (c == '"')
					{
						bInString = false;
					}
				}
				else
				{
					switch (c)
					{
						case ':':
						{
							// new section
							string sQuotes = @"""";

							if ( ! sID.Contains(sQuotes) )
							{
								sID = sStripWhitespaces(sID);
								OpenSection(sID);
								
								sParseStream(_szStream,ref i);
								
								CloseSection();
								sID="";
							}
							else
							{
								// We are parsing a string value ...
								sID = sID + c;
							}
						}
						break;
							
						case '}':
						{
						}	        
						break;
							
						case '{':
							sID="";
						break;
							
						case '\n':
						case '\t':
						case ' ':
						{
						};
						break;
							
						// close section or variable
						case ';':				
						{					
							return( sID );
						}
                        // break; // commented to avoid warning CS0162: Unreachable code detected

                        // close section or variable
                        case '"':
						{
							// we need also quotes to identitfy numbers inside a string from plain numbers
							sID = sID + c;
							bInString = true;
						}
						break;
							
						case '=':
						{					
							// new variable
							sID = sStripWhitespaces(sID);
							string sValue = sParseStream(_szStream,ref i);
							
							AddVar(sID, sStripQuotes(sValue) );
							sID="";
						}
						break;
							
						default:
						{
							sID = sID + c;
						}
						break;
					}
				}
			}

            return ("");
		}

		// ----------------------------------------------------------------------------
		private void AddVar(string _sVariable,string _sValue)
		{
			string sFullQualifiedVar = sGetCurrentSection() + "." + _sVariable;
			m_oVars.Add( sFullQualifiedVar,new CVariable(_sVariable, _sValue) );
		}
		// ----------------------------------------------------------------------------
		private string sGetCurrentSection()
		{
			if (m_sSection.Count > 0)
				return(m_sSection[m_sSection.Count - 1]);
			else
				return("");
		}

		private void OpenSection(string _sSection)
		{
			if (m_sSection.Count > 0)
				m_sSection.Add( m_sSection[m_sSection.Count - 1] + "." + _sSection );
			else
				m_sSection.Add( _sSection );
		}

		private void CloseSection()
		{
			m_sSection.RemoveAt( m_sSection.Count-1 );
		}
		// ----------------------------------------------------------------------------
		// ----------------------------------------------------------------------------
		// Utility functions
		// ----------------------------------------------------------------------------
		// ----------------------------------------------------------------------------
		private char[] pucReadFile(string _szFilename)
		{
			Godot.File file = new Godot.File();
			if (! file.FileExists(_szFilename))
			{
				return null;
			}

			file.Open(_szFilename,	Godot.File.ModeFlags.Read);
		
			string content = file.GetAsText();

			char[] fileData = new char[content.Length+1];
			Array.Copy(content.ToCharArray(), fileData, content.Length);
			fileData[content.Length] = '\0';
			file.Close();
			return fileData;

			/*
			if (! ResourceLoader.Exists(_szFilename))
			{
				return(null);
			}
			
			var fileContent = ResourceLoader.Load(_szFilename);
			return fileContent.ToString().ToCharArray(); // System.Text.Encoding.ASCII.GetString(fileContent.ToString()).ToCharArray();
			*/
		}
		
		// ----------------------------------------------------------------------------
		private void SubstChar(char[] _szStream,char _cChar)
		{
			int i = 0;
			while (_szStream[i] != 0)
			{
				if (_szStream[i] == _cChar)
					_szStream[i] = ' ';
				
				i++;
			};
		}
		
		// ---------------------------------------------------------------------------
		/// Preprocess a stream of data replacing comments by space chars
		// ---------------------------------------------------------------------------
		private void PreprocessComments(char[] _szStream)
		{
			// skip non comment characters
			int i = 0;
			while (_szStream[i] != 0)
			{
				bool bCommentFound = false;
				while ((_szStream[i] != 0) && (_szStream[i] != '\r') && (_szStream[i] != '\n') && (!bCommentFound))
				{
					if ((_szStream[i+0] == '/') && (_szStream[i+1] == '/'))
						bCommentFound = true;
					else
						i++;
				};

				// remove comment
				if (bCommentFound)
				{
					while ((_szStream[i] != 0) && (_szStream[i] != '\r') && (_szStream[i] != '\n'))
					{
						_szStream[i] = ' ';
						i++;
					};
				}

				// skip /r /n
				while (
						((_szStream[i] == '\r') || (_szStream[i] == '\n'))
					  && (_szStream[i] != 0)
						)
					i++;
			}
		}

		// ---------------------------------------------------------------------------
		/// Preprocess a stream of data and takes out empty sections
		// ---------------------------------------------------------------------------
		private bool bRemoveEmptySections(char[] _szStream,int _iStart)
		{
			// ------------------------------------------
			// Look if the stream starts with a section
			// ------------------------------------------
			bool bEmptySection = true;
			int iSectionStart  = _iStart;
			int i = _iStart;
	
			while ( _szStream[i] != 0)
			{
				char c = _szStream[i];
				i++;
				
				switch (c)
				{
					case '}':
					{
						return( bEmptySection );
					}
                    // break; // commented to avoid warning CS0162: Unreachable code detected

                    case ';':
					{
						iSectionStart = i+1;
					};
					break;
						
					case '{':
					{
						if (bRemoveEmptySections(_szStream,i))
						{
							while (_szStream[iSectionStart] != '}')
							{
								_szStream[iSectionStart] = ' ';
								iSectionStart++;
							};
							
							// remove '}'
							while (_szStream[iSectionStart] != ';')
							{
								_szStream[iSectionStart] = ' ';
								iSectionStart++;						
							};
	
							// remove ';'
							_szStream[iSectionStart] = ' ';
							iSectionStart++;
						}
						else
						{
							bEmptySection = false;
						}
					}
					break;
						
					case '=':
					{
						bEmptySection = false;
					}
					break;
				}
			}
	
			return(true);
		}

		// ----------------------------------------------------------------------------
		private string sStripCharacter(string _sStr,char _cCharToStrip)
		{
			if (_sStr == "") return("");

			char[] szStream = _sStr.ToCharArray();
			string sRes = "";

			for (int i=0;i<_sStr.Length;i++)
			{
				if (szStream[i] != _cCharToStrip)
					sRes += szStream[i];
			};

			return(sRes);
		}
		// ----------------------------------------------------------------------------
		private string sStripWhitespaces(string _sStr)
		{
			return(sStripCharacter(_sStr,' '));
		}
		// ----------------------------------------------------------------------------
		private string sStripQuotes(string _sStr)
		{
			return(sStripCharacter(_sStr,'\"'));
		}
		// ----------------------------------------------------------------------------
		// Section management
		private List<string> m_sSection = new List<string>();
		
		// storage for all the variables.
		private Dictionary<string,CVariable> m_oVars = new Dictionary<string, CVariable>();
	}
}
